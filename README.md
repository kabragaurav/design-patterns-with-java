# Design Patterns with Java (LLD)
by Gaurav Kabra

![](./assets/images/types.png)
![](./assets/images/hierarchy.png)


# Creational
![](./assets/images/creational.png)

### 1. Singleton
Logger, DB Connector 
Disadv:
- Multi threaded env: access must be thread safe
- Dependency inversion regards this as an anti-pattern since use of private and static methods

![](./assets/images/singleton.png)

### 2. Factory
Singleton, in some sense, is also a factory pattern but returns only one type of object.

Also, in factory pattern, clients do not even know the name of class for which object is to be generated. They only know Factory name.

E.g. DB Connector Factory using getConnection method, depending on DB driver. E.g. Oracle driver:
```
Connection conn = DriverManager.getConnection("url", "uname", "pwd");
```
Now different DB vendors have different URL formats.

Different vendors implement the JDBC interfaces.

![](./assets/images/factory.png)
![](./assets/images/factory_2.png)
![](./assets/images/factory_eg.png)

### 3. Abstract Factory
Factory for factories. E.g. a factory that returns Maruti factory or Skoda factory:

![](./assets/images/abstract_factory.png)
![](./assets/images/abstract_factory_eg.png)
![](./assets/images/abstract_factory_comp.png)

### 4. Prototype
For cloning - shallow or deep.

In Java, unlike Python, we have to implement our own shallow/deep copy methods.

![](./assets/images/proto.png)

# Structural

### 1. Adapter
When we do not have src code, so no modification is possible.

![](./assets/images/adapter.png)

### 2. Proxy
Unlike Adapter, which does "conversion", in Proxy pattern, one object represents another.

Both RealSubject and Proxy must have same method signatures.

Useful in caching responses (optimizations), where first time original class fetches from DB but then proxy caches the response.

![](./assets/images/proxy.png)
![](./assets/images/proxy_eg.png)
![](./assets/images/proxy_uses.png)

#### RMI
(Now deprecated due to RPC)

A method can call only method within same JVM. But RMI allows it to invoke method in another JVM, may be on another OS.
![](./assets/images/rmi.png)

Communication happens via RMI interface (proprietary to Java) unlike HTTPS.
Stub and Skeleton are generated by RMI. Stub passes information like method to be invoked and parameters. Skeleton executes using this info and returns results.

### 3. Facade
E.g. customer service can answer all queries, we reach to warden regarding any hostel query etc.

![](./assets/images/facade.png)
![](./assets/images/facade_eg.png)

### 4. Decorator
If `classA` has features `f1` and `f2` and a `classB` has features `f13` and `f4` and we just want features `f1` and `f4`.

It helps avoid inheritance.

Base class will be same to have common behaviour.

![](./assets/images/decorator.png)
![](./assets/images/decorator_eg.png)
![](./assets/images/decorator_eg_2.png)

Unlike inheritance, decorator is plug-n-play.

![](./assets/images/decorator_vs_inherit.png)

# Behavioral
![](./assets/images/behave.png)
### 1. Strategy

With composition, it's easy to change behavior on the fly with Dependency Injection / Setters. Inheritance is more rigid as most languages do not allow you to derive from more than one type.

Does TypeB want to expose the complete interface (all public methods no less) of TypeA? Indicates Inheritance.

Does TypeB want only some/part of the behavior exposed by TypeA? Indicates need for Composition.

![](./assets/images/strategy.png)
![](./assets/images/no_inheritance.png)
![](./assets/images/yes_strategy.png)

### 2. Chain of Responsibility
When enter corporate SEZ, multiple layer of security. Similarly in govt work, file moves through hierarchy/layers.

![](./assets/images/cor.png)

Useful in performing incremental operations (pipeline), doing auth then logging and so on (Servlet FilterChain).

![](./assets/images/filter_chain.png)

If 100 cannot handle 2140, it delegates to 50 and so on:

![](./assets/images/cor_eg.png)

### 3. Observer
1-N dependency, event handling and decoupling

![](./assets/images/observer.png)
![](./assets/images/observer_eg.png)

### 4. State
![](./assets/images/state.png)
![](./assets/images/state_eg.png)
![](./assets/images/state_vs_strategy.png)

##### State vs Chain of Responsibility
- In State, they act on same object, so that they form finite state automaton
- In CoR, each class gets different objects from previous class that does processing and then passes

### 5. Command
We don't need if we use Reflection, but that is generally an anti-pattern.

On a complex operation on DB, invoker should not know what is to execute. Whatever instructions you set as a command, it should execute.

![](./assets/images/command.png)
![](./assets/images/command_2.png)

---

# Resources
- https://sourcemaking.com/